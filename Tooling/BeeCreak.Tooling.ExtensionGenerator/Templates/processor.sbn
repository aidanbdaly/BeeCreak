{{ has_non_collection = false -}}
{{ for prop in asset.properties -}}
{{ if !prop.iscollection }}{{ has_non_collection = true }}{{ end -}}
{{ end -}}
using System;
using Microsoft.Xna.Framework.Content.Pipeline;
{{ for ns in required_namespaces -}}
using {{ ns }};

{{ end -}}

namespace {{ namespace }};

[ContentProcessor(DisplayName = "{{ asset.name }} Processor")]
public sealed class {{ asset.name }}Processor : ContentProcessor<{{ asset.name }}Dto, {{ asset.name }}Content>
{
    public override {{ asset.name }}Content Process({{ asset.name }}Dto input, ContentProcessorContext context)
    {
        AssertValid(input);

{{ if has_non_collection -}}
        var content = new {{ asset.name }}Content
        {
{{ for prop in asset.properties -}}
{{ if !prop.iscollection -}}
            {{ prop.name }} = {{ if prop.isreference }}string.IsNullOrWhiteSpace(input.{{ prop.name }}) ? null : LoadAsset<{{ prop.referenceassetname }}Content>(input.{{ prop.name }}, "{{ prop.referenceassetname }}", "{{ prop.referencecontentdirectory }}", "{{ prop.referencefileextension }}", "{{ prop.referenceprocessorname }}", context){{ else if prop.iscomplex }}Map{{ prop.name }}(input.{{ prop.name }}, context){{ else }}input.{{ prop.name }}{{ end }},
{{ end -}}
{{ end -}}
        };
{{ else -}}
        var content = new {{ asset.name }}Content();
{{ end }}

{{ for prop in asset.properties -}}
{{ if prop.isarray -}}

        if (input.{{ prop.name }} is not null)
        {
            foreach (var item in input.{{ prop.name }})
            {
{{ if prop.elementiscomplex -}}
                content.{{ prop.name }}.Add(Map{{ prop.name }}Entry(item, context));
{{ else if prop.iselementreference -}}
{{ if prop.elementisstring -}}
                if (string.IsNullOrWhiteSpace(item))
                {
                    continue;
                }
{{ end -}}
                content.{{ prop.name }}.Add(LoadAsset<{{ prop.elementreferenceassetname }}Content>(item, "{{ prop.elementreferenceassetname }}", "{{ prop.elementreferencecontentdirectory }}", "{{ prop.elementreferencefileextension }}", "{{ prop.elementreferenceprocessorname }}", context));
{{ else -}}
{{ if prop.elementisstring -}}
                content.{{ prop.name }}.Add(item ?? string.Empty);
{{ else -}}
                content.{{ prop.name }}.Add(item);
{{ end -}}
{{ end -}}
            }
        }
{{ else if prop.isdictionary -}}

        if (input.{{ prop.name }} is not null)
        {
            foreach (var entry in input.{{ prop.name }})
            {
{{ if prop.elementiscomplex -}}
                content.{{ prop.name }}[entry.Key] = Map{{ prop.name }}Entry(entry.Value, context);
{{ else if prop.iselementreference -}}
{{ if prop.elementisstring -}}
                if (string.IsNullOrWhiteSpace(entry.Value))
                {
                    continue;
                }
{{ end -}}
                content.{{ prop.name }}[entry.Key] = LoadAsset<{{ prop.elementreferenceassetname }}Content>(entry.Value, "{{ prop.elementreferenceassetname }}", "{{ prop.elementreferencecontentdirectory }}", "{{ prop.elementreferencefileextension }}", "{{ prop.elementreferenceprocessorname }}", context);
{{ else -}}
                content.{{ prop.name }}[entry.Key] = entry.Value;
{{ end -}}
            }
        }
{{ end -}}
{{ end -}}

        return content;
    }

    private static void AssertValid({{ asset.name }}Dto input)
    {
        if (input is null)
        {
            throw new InvalidContentException("{{ asset.name }} payload is empty.");
        }

{{ for prop in asset.properties -}}
{{ if prop.isrequired -}}
{{ if prop.isstring -}}
        if (string.IsNullOrWhiteSpace(input.{{ prop.name }}))
        {
            throw new InvalidContentException("{{ asset.name }} requires '{{ prop.json_name }}'.");
        }

{{ else if prop.isarray -}}
{{~ min_items = prop.minitems ?? 0 ~}}
        if (input.{{ prop.name }} is null{{ if min_items > 0 }} || input.{{ prop.name }}.Count < {{ min_items }}{{ end }})
        {
{{ if min_items > 0 -}}
            throw new InvalidContentException("{{ asset.name }} requires at least {{ min_items }} '{{ prop.json_name }}' entries.");
{{ else -}}
            throw new InvalidContentException("{{ asset.name }} requires '{{ prop.json_name }}'.");
{{ end -}}
        }

{{ else if prop.isdictionary -}}
{{~ min_properties = prop.minproperties ?? 0 ~}}
        if (input.{{ prop.name }} is null{{ if min_properties > 0 }} || input.{{ prop.name }}.Count < {{ min_properties }}{{ end }})
        {
{{ if min_properties > 0 -}}
            throw new InvalidContentException("{{ asset.name }} requires at least {{ min_properties }} '{{ prop.json_name }}' entries.");
{{ else -}}
            throw new InvalidContentException("{{ asset.name }} requires '{{ prop.json_name }}'.");
{{ end -}}
        }
{{ end -}}
{{ end -}}
{{ end -}}
    }

{{ for prop in asset.properties -}}
{{ if prop.iscomplex -}}
    private static {{ asset.name }}Content.{{ prop.name }}Content Map{{ prop.name }}({{ asset.name }}Dto.{{ prop.name }}Dto? input, ContentProcessorContext context)
    {
        if (input is null)
        {
            return new {{ asset.name }}Content.{{ prop.name }}Content();
        }

        var content = new {{ asset.name }}Content.{{ prop.name }}Content();
{{ for nested in prop.complexproperties -}}
{{ if nested.iscomplex -}}
        content.{{ nested.name }} = Map{{ prop.name }}{{ nested.name }}(input.{{ nested.name }}, context);
{{ else if nested.isreference -}}
        content.{{ nested.name }} = string.IsNullOrWhiteSpace(input.{{ nested.name }}) ? null : LoadAsset<{{ nested.referenceassetname }}Content>(input.{{ nested.name }}, "{{ nested.referenceassetname }}", "{{ nested.referencecontentdirectory }}", "{{ nested.referencefileextension }}", "{{ nested.referenceprocessorname }}", context);
{{ else -}}
        content.{{ nested.name }} = input.{{ nested.name }};
{{ end -}}

{{ end -}}
        return content;
    }

{{ end -}}
{{ if prop.iscollection && prop.elementiscomplex -}}
    private static {{ asset.name }}Content.{{ prop.elementcomplexclassname }}Content Map{{ prop.name }}Entry({{ asset.name }}Dto.{{ prop.elementcomplexclassname }}Dto? input, ContentProcessorContext context)
    {
        if (input is null)
        {
            return new {{ asset.name }}Content.{{ prop.elementcomplexclassname }}Content();
        }

        var content = new {{ asset.name }}Content.{{ prop.elementcomplexclassname }}Content();
{{ for nested in prop.elementcomplexproperties -}}
{{ if nested.iscomplex -}}
        content.{{ nested.name }} = Map{{ prop.name }}{{ nested.name }}Entry(input.{{ nested.name }}, context);
{{ else if nested.isreference -}}
        content.{{ nested.name }} = string.IsNullOrWhiteSpace(input.{{ nested.name }}) ? null : LoadAsset<{{ nested.referenceassetname }}Content>(input.{{ nested.name }}, "{{ nested.referenceassetname }}", "{{ nested.referencecontentdirectory }}", "{{ nested.referencefileextension }}", "{{ nested.referenceprocessorname }}", context);
{{ else -}}
        content.{{ nested.name }} = input.{{ nested.name }};
{{ end -}}

{{ end -}}
        return content;
    }

{{ end -}}
{{ end -}}
    private static TContent LoadAsset<TContent>(
        string assetId,
        string assetName,
        string directory,
        string extension,
        string processor,
        ContentProcessorContext context)
    {
        if (string.IsNullOrWhiteSpace(assetId))
        {
            throw new InvalidContentException($"{assetName} reference is empty.");
        }

        var assetPath = string.Concat(directory, "/", assetId, extension);
        var reference = new ExternalReference<TContent>(assetPath);

        try
        {
            return context.BuildAndLoadAsset<TContent, TContent>(reference, processor);
        }
        catch (Exception ex)
        {
            throw new InvalidContentException($"{assetName} '{assetId}' failed to load: {ex.Message}", ex);
        }
    }
}
